{"version":3,"sources":["webpack:///./node_modules/mobx-react-lite/dist/index.module.js","webpack:///./node_modules/react-transition-group/esm/TransitionGroupContext.js","webpack:///./node_modules/react-transition-group/esm/config.js","webpack:///./node_modules/react-transition-group/esm/Transition.js","webpack:///./node_modules/react-hook-form/dist/react-hook-form.es.js","webpack:///./node_modules/react-transition-group/esm/SwitchTransition.js","webpack:///./node_modules/dom-helpers/esm/removeClass.js","webpack:///./node_modules/react-transition-group/esm/CSSTransition.js","webpack:///./node_modules/dom-helpers/esm/addClass.js","webpack:///./node_modules/dom-helpers/esm/hasClass.js"],"names":["Error","globalIsUsingStaticRendering","isUsingStaticRendering","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","printDebugValue","v","current","EMPTY_ARRAY","useForceUpdate","setTick","tick","EMPTY_OBJECT","useObserver","fn","baseComponentName","options","forceUpdate","reaction","rendering","exception","dispose","isDisposed","useUnmount","track","observer","baseComponent","memoComponent","realOptions","forwardRef","displayName","name","wrappedComponent","props","ref","base","target","keys","forEach","key","hoistBlackList","defineProperty","getOwnPropertyDescriptor","copyStaticProperties","$$typeof","render","compare","type","ObserverComponent","_a","children","component","ObserverPropsCheck","componentName","location","propFullName","extraKey","hasProp","hasExtraProp","propTypes","createContext","ENTERING","ENTERED","EXITING","_React$Component","Transition","context","_this","initialStatus","appear","isMounting","enter","appearStatus","in","unmountOnExit","mountOnEnter","state","status","nextCallback","getDerivedStateFromProps","_ref","prevState","_proto","componentDidMount","updateStatus","componentDidUpdate","prevProps","nextStatus","componentWillUnmount","cancelNextCallback","getTimeouts","exit","timeout","undefined","mounting","node","findDOMNode","performEnter","performExit","setState","_this2","appearing","timeouts","enterTimeout","config","safeSetState","onEntered","onEnter","onEntering","onTransitionEnd","_this3","onExit","onExiting","onExited","cancel","nextState","callback","setNextCallback","_this4","active","event","handler","doesNotHaveTimeoutOrListener","addEndListener","setTimeout","_this$props","childProps","createElement","TransitionGroupContext","Provider","child","Children","only","cloneElement","Component","noop","contextType","defaultProps","UNMOUNTED","EXITED","isNullOrUndefined","isArray","Array","isObjectType","isObject","isHTMLElement","nodeType","Node","ELEMENT_NODE","VALIDATION_MODE","onBlur","onChange","onSubmit","EVENTS","INPUT_VALIDATION_RULES","REGEX_IS_DEEP_PROP","REGEX_IS_PLAIN_PROP","REGEX_PROP_NAME","REGEX_ESCAPE_CHAR","isKey","test","stringToPath","string","result","replace","match","number","quote","set","object","path","index","tempPath","lastIndex","newValue","objValue","isNaN","transformToNestObject","data","entries","reduce","previous","isUndefined","val","get","obj","defaultValue","split","filter","Boolean","removeAllEventListeners","validateWithStateUpdate","removeEventListener","isRadioInput","element","isCheckBoxInput","isDetached","HTMLElement","DOCUMENT_NODE","parentNode","isEmptyObject","castPath","parent","updatePath","baseGet","array","start","end","baseSlice","unset","paths","childObject","previousObjRef","k","slice","objectRef","currentPaths","currentPathsLength","item","baseUnset","isSameRef","fieldValue","defaultReturn","isValid","getRadioValue","option","checked","isFileInput","isMultipleSelect","isEmptyString","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fields","field","files","selected","getMultipleSelectValue","isString","getFieldsValues","search","output","startsWith","find","nest","isSameError","types","message","objectA","objectB","objectAKeys","objectBKeys","every","compareObject","isRegex","RegExp","getValueAndMessage","validationData","isValueMessage","isFunction","isBoolean","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","errors","validateField","async","fieldsRef","required","maxLength","minLength","min","max","pattern","validate","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","requiredValue","requiredMessage","exceedMin","maxValue","maxMessage","minValue","minMessage","valueNumber","valueAsNumber","parseFloat","valueDate","valueAsDate","Date","maxLengthValue","minLengthValue","inputLength","toString","patternValue","patternMessage","validateRef","validateError","validationResult","validateFunction","parseErrorSchema","inner","validateWithSchema","validationSchema","validationResolver","abortEarly","isPrimitive","getPath","getInnerPath","pathWithIndex","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","parentPath","flat","Infinity","getPath$1","skipValidation","isOnChange","hasError","isBlurEvent","isOnSubmit","isReValidateOnSubmit","isOnBlur","isReValidateOnBlur","isSubmitted","getFieldArrayParentName","substring","indexOf","getFieldValueByName","results","getIsFieldsDifferent","referenceArray","differenceArray","isMatch","dataA","dataB","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","modeChecker","mode","isRadioOrCheckboxFunction","useForm","reValidateMode","validationContext","defaultValues","submitFocusError","validateCriteriaMode","errorsRef","touchedFieldsRef","fieldArrayDefaultValues","watchFieldsRef","Set","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","isValidRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","handleChangeRef","resetFieldArrayFunctionRef","validationContextRef","fieldArrayNamesRef","isWindowUndefined","window","shouldValidateSchemaOrResolver","isWeb","document","isProxyEnabled","Proxy","readFormStateRef","dirty","dirtyFields","submitCount","touched","isSubmitting","reRender","shouldRenderBaseOnError","shouldRender","shouldReRender","validFields","fieldsWithValidation","isFieldValid","isFormValid","currentFieldError","existFieldError","has","isManual","shouldRenderBasedOnError","delete","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","setDirty","isFieldDirty","isFieldArray","previousDirtyFieldsLength","size","fieldArrayName","isDirtyChanged","setDirtyAndTouchedFields","setInternalValues","parentFieldName","isValueArray","setInternalValue","executeValidation","skipReRender","executeSchemaOrResolverValidation","payload","previousFormIsValid","triggerValidation","Promise","all","isFieldWatched","currentError","shouldSkipValidation","shouldUpdateDirty","validateSchemaOrResolver","then","removeFieldEventListener","forceDelete","handleChange","mutationWatcher","disconnect","findRemovedFieldAndRemoveListener","removeFieldEventListenerAndRef","setInternalError","registerFieldsRef","validateOptions","fieldRefAndValidationOptions","isEmptyDefaultValue","onDetachCallback","MutationObserver","observe","childList","subtree","onDomRemove","addEventListener","attachEventListeners","handleSubmit","preventDefault","persist","fieldErrors","fieldError","focus","focusOnErrorField","formState","commonProps","setValue","valueOrShouldValidate","shouldValidate","isArrayValue","isStringFieldName","register","refOrValidationOptions","validationOptions","unregister","getValues","outputValues","prop","control","validateSchemaIsValid","watch","fieldNames","isDefaultValueUndefined","combinedDefaultValues","reset","omitResetState","inputRef","closest","resetFieldArray","resetRefs","clearError","setError","_leaveRenders","_enterRenders","modes","callHook","cb","_element$props","leaveRenders","changeState","_ref2","enterRenders","_ref3","_ref4","SwitchTransition","_len","args","_key","concat","appeared","oldChildren","newChildren","isValidElement","areChildrenDifferent","_this$state","replaceClassName","origClass","classToRemove","classes","c","className","classList","remove","setAttribute","baseVal","CSSTransition","appliedClasses","removeClasses","addClass","getClassNames","classNames","isStringClassNames","baseClassName","activeClassName","doneClassName","phase","scrollTop","contains","hasClass","_addClass","_this$appliedClasses$"],"mappings":"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","file":"3.js","sourcesContent":["import { spy, observable, computed, getDependencyTree, Reaction, runInAction, transaction, configure } from 'mobx';\nimport React, { useState, useRef, useMemo, useEffect, useCallback, useDebugValue, memo, forwardRef } from 'react';\n\nif (!useState) {\r\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\r\n}\r\nif (!spy) {\r\n    throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\");\r\n}\n\nfunction useObservable(initialValue) {\r\n    var observableRef = useRef(null);\r\n    if (!observableRef.current) {\r\n        observableRef.current = observable(initialValue);\r\n    }\r\n    return observableRef.current;\r\n}\n\nfunction useComputed(func, inputs) {\r\n    if (inputs === void 0) { inputs = []; }\r\n    var computed$1 = useMemo(function () { return computed(func); }, inputs);\r\n    return computed$1.get();\r\n}\n\nvar doNothingDisposer = function () {\r\n    // empty\r\n};\r\n/**\r\n * Adds an observable effect (reaction, autorun, or anything else that returns a disposer) that will be registered upon component creation and disposed upon unmounting.\r\n * Returns the generated disposer for early disposal.\r\n *\r\n * @export\r\n * @template D\r\n * @param {() => D} disposerGenerator A function that returns the disposer of the wanted effect.\r\n * @param {ReadonlyArray<any>} [inputs=[]] If you want the effect to be automatically re-created when some variable(s) are changed then pass them in this array.\r\n * @returns {D}\r\n */\r\nfunction useDisposable(disposerGenerator, inputs) {\r\n    if (inputs === void 0) { inputs = []; }\r\n    var disposerRef = useRef(null);\r\n    var earlyDisposedRef = useRef(false);\r\n    useEffect(function () {\r\n        return lazyCreateDisposer(false);\r\n    }, inputs);\r\n    function lazyCreateDisposer(earlyDisposal) {\r\n        // ensure that we won't create a new disposer if it was early disposed\r\n        if (earlyDisposedRef.current) {\r\n            return doNothingDisposer;\r\n        }\r\n        if (!disposerRef.current) {\r\n            var newDisposer = disposerGenerator();\r\n            if (typeof newDisposer !== \"function\") {\r\n                var error = new Error(\"generated disposer must be a function\");\r\n                {\r\n                    // tslint:disable-next-line:no-console\r\n                    console.error(error);\r\n                    return doNothingDisposer;\r\n                }\r\n            }\r\n            disposerRef.current = newDisposer;\r\n        }\r\n        return function () {\r\n            if (disposerRef.current) {\r\n                disposerRef.current();\r\n                disposerRef.current = null;\r\n            }\r\n            if (earlyDisposal) {\r\n                earlyDisposedRef.current = true;\r\n            }\r\n        };\r\n    }\r\n    return lazyCreateDisposer(true);\r\n}\n\nvar globalIsUsingStaticRendering = false;\r\nfunction useStaticRendering(enable) {\r\n    globalIsUsingStaticRendering = enable;\r\n}\r\nfunction isUsingStaticRendering() {\r\n    return globalIsUsingStaticRendering;\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\n\nfunction printDebugValue(v) {\r\n    if (!v.current) {\r\n        return \"<unknown>\";\r\n    }\r\n    return getDependencyTree(v.current);\r\n}\n\nvar EMPTY_ARRAY = [];\r\nfunction useUnmount(fn) {\r\n    useEffect(function () { return fn; }, EMPTY_ARRAY);\r\n}\r\nfunction useForceUpdate() {\r\n    var _a = __read(useState(0), 2), setTick = _a[1];\r\n    var update = useCallback(function () {\r\n        setTick(function (tick) { return tick + 1; });\r\n    }, []);\r\n    return update;\r\n}\r\nfunction isPlainObject(value) {\r\n    if (!value || typeof value !== \"object\") {\r\n        return false;\r\n    }\r\n    var proto = Object.getPrototypeOf(value);\r\n    return !proto || proto === Object.prototype;\r\n}\n\nvar EMPTY_OBJECT = {};\r\nfunction useObserver(fn, baseComponentName, options) {\r\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\r\n    if (options === void 0) { options = EMPTY_OBJECT; }\r\n    if (isUsingStaticRendering()) {\r\n        return fn();\r\n    }\r\n    var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\r\n    var forceUpdate = wantedForceUpdateHook();\r\n    var reaction = useRef(null);\r\n    if (!reaction.current) {\r\n        reaction.current = new Reaction(\"observer(\" + baseComponentName + \")\", function () {\r\n            forceUpdate();\r\n        });\r\n    }\r\n    var dispose = function () {\r\n        if (reaction.current && !reaction.current.isDisposed) {\r\n            reaction.current.dispose();\r\n            reaction.current = null;\r\n        }\r\n    };\r\n    useDebugValue(reaction, printDebugValue);\r\n    useUnmount(function () {\r\n        dispose();\r\n    });\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    var rendering;\r\n    var exception;\r\n    reaction.current.track(function () {\r\n        try {\r\n            rendering = fn();\r\n        }\r\n        catch (e) {\r\n            exception = e;\r\n        }\r\n    });\r\n    if (exception) {\r\n        dispose();\r\n        throw exception; // re-throw any exceptions catched during rendering\r\n    }\r\n    return rendering;\r\n}\n\n// n.b. base case is not used for actual typings or exported in the typing files\r\nfunction observer(baseComponent, options) {\r\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\r\n    if (isUsingStaticRendering()) {\r\n        return baseComponent;\r\n    }\r\n    var realOptions = __assign({ forwardRef: false }, options);\r\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\r\n    var wrappedComponent = function (props, ref) {\r\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\r\n    };\r\n    wrappedComponent.displayName = baseComponentName;\r\n    // memo; we are not intested in deep updates\r\n    // in props; we assume that if deep objects are changed,\r\n    // this is in observables, which would have been tracked anyway\r\n    var memoComponent;\r\n    if (realOptions.forwardRef) {\r\n        // we have to use forwardRef here because:\r\n        // 1. it cannot go before memo, only after it\r\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\r\n        //    since it wouldn't be a callable function anymore\r\n        memoComponent = memo(forwardRef(wrappedComponent));\r\n    }\r\n    else {\r\n        memoComponent = memo(wrappedComponent);\r\n    }\r\n    copyStaticProperties(baseComponent, memoComponent);\r\n    memoComponent.displayName = baseComponentName;\r\n    return memoComponent;\r\n}\r\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\r\nvar hoistBlackList = {\r\n    $$typeof: true,\r\n    render: true,\r\n    compare: true,\r\n    type: true\r\n};\r\nfunction copyStaticProperties(base, target) {\r\n    Object.keys(base).forEach(function (key) {\r\n        if (base.hasOwnProperty(key) && !hoistBlackList[key]) {\r\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\r\n        }\r\n    });\r\n}\n\nfunction ObserverComponent(_a) {\r\n    var children = _a.children, render = _a.render;\r\n    var component = children || render;\r\n    if (typeof component !== \"function\") {\r\n        return null;\r\n    }\r\n    return useObserver(component);\r\n}\r\nObserverComponent.propTypes = {\r\n    children: ObserverPropsCheck,\r\n    render: ObserverPropsCheck\r\n};\r\nObserverComponent.displayName = \"Observer\";\r\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\r\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\r\n    var hasProp = typeof props[key] === \"function\";\r\n    var hasExtraProp = typeof props[extraKey] === \"function\";\r\n    if (hasProp && hasExtraProp) {\r\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\r\n    }\r\n    if (hasProp || hasExtraProp) {\r\n        return null;\r\n    }\r\n    return new Error(\"Invalid prop `\" +\r\n        propFullName +\r\n        \"` of type `\" +\r\n        typeof props[key] +\r\n        \"` supplied to\" +\r\n        \" `\" +\r\n        componentName +\r\n        \"`, expected `function`.\");\r\n}\n\nfunction useAsObservableSourceInternal(current, usedByLocalStore) {\r\n    if (usedByLocalStore && current === undefined) {\r\n        return undefined;\r\n    }\r\n    var _a = __read(React.useState(function () { return observable(current, {}, { deep: false }); }), 1), res = _a[0];\r\n    runInAction(function () {\r\n        Object.assign(res, current);\r\n    });\r\n    return res;\r\n}\r\nfunction useAsObservableSource(current) {\r\n    return useAsObservableSourceInternal(current, false);\r\n}\n\nfunction useLocalStore(initializer, current) {\r\n    var source = useAsObservableSourceInternal(current, true);\r\n    return React.useState(function () {\r\n        var local = observable(initializer(source));\r\n        if (isPlainObject(local)) {\r\n            runInAction(function () {\r\n                Object.keys(local).forEach(function (key) {\r\n                    var value = local[key];\r\n                    if (typeof value === \"function\") {\r\n                        // @ts-ignore No idea why ts2536 is popping out here\r\n                        local[key] = wrapInTransaction(value, local);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return local;\r\n    })[0];\r\n}\r\n// tslint:disable-next-line: ban-types\r\nfunction wrapInTransaction(fn, context) {\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return transaction(function () { return fn.apply(context, args); });\r\n    };\r\n}\n\nvar optimizeScheduler = function (reactionScheduler) {\r\n    if (typeof reactionScheduler === \"function\") {\r\n        configure({ reactionScheduler: reactionScheduler });\r\n    }\r\n};\n\nexport { ObserverComponent as Observer, isUsingStaticRendering, observer, optimizeScheduler, useAsObservableSource, useComputed, useDisposable, useForceUpdate, useLocalStore, useObservable, useObserver, useStaticRendering };\n","import React from 'react';\nexport default React.createContext(null);","export default {\n  disabled: false\n};","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport config from './config';\nimport { timeoutsShape } from './utils/PropTypes';\nimport TransitionGroupContext from './TransitionGroupContext';\nexport var UNMOUNTED = 'unmounted';\nexport var EXITED = 'exited';\nexport var ENTERING = 'entering';\nexport var ENTERED = 'entered';\nexport var EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\n * transitions in CSS, you'll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the\n * components. It's up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from 'react-transition-group';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the \"Enter\" stage. During this stage, the component will shift from\n * its current transition state, to `'entering'` for the duration of the\n * transition and then to the `'entered'` stage once it's complete. Let's take\n * the following example (we'll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `'exiting'` to `'exited'`.\n */\n\nvar Transition =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  }; // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n      var node = ReactDOM.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(node, appearing);\n\n      _this2.onTransitionEnd(node, enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED\n\n    if (!exit || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n\n    this.props.onExit(node);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      this.props.addEndListener(node, this.nextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\"]); // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      // allows for nested Transitions\n      return React.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, children(status, childProps));\n    }\n\n    var child = React.Children.only(children);\n    return (// allows for nested Transitions\n      React.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, React.cloneElement(child, childProps))\n    );\n  };\n\n  return Transition;\n}(React.Component);\n\nTransition.contextType = TransitionGroupContext;\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the\n   * `<Transition>` component mounts. If you want to transition on the first\n   * mount set `appear` to `true`, and the component will transition in as soon\n   * as the `<Transition>` mounts.\n   *\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\n   * > only adds an additional enter transition. However, in the\n   * > `<CSSTransition>` component that first enter transition does result in\n   * > additional `.appear-*` classes, that way you can choose to style it\n   * > differently.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function timeout(props) {\n    var pt = timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return pt.apply(void 0, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func // Name the function so it is clearer in the documentation\n\n} : {};\n\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\nexport default Transition;","import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement, Fragment } from 'react';\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst VALUE = 'value';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\r\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\r\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\r\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\n\nfunction attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isKey = (value) => !isArray(value) &&\r\n    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nvar stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction castPath(value) {\r\n    return isArray(value) ? value : stringToPath(value);\r\n}\r\nfunction baseGet(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return index == length ? object : undefined;\r\n}\r\nfunction baseSlice(array, start, end) {\r\n    let index = -1;\r\n    let length = array.length;\r\n    if (start < 0) {\r\n        start = -start > length ? 0 : length + start;\r\n    }\r\n    end = end > length ? length : end;\r\n    if (end < 0) {\r\n        end += length;\r\n    }\r\n    length = start > end ? 0 : end - start;\r\n    const result = Array(length);\r\n    while (++index < length) {\r\n        result[index] = array[index + start];\r\n    }\r\n    return result;\r\n}\r\nfunction parent(object, path) {\r\n    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n}\r\nfunction baseUnset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const childObject = parent(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    const result = !(childObject != null) || delete childObject[key];\r\n    let previousObjRef = undefined;\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index) {\r\n                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length)) {\r\n                    previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n                }\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction unset(object, paths) {\r\n    paths.forEach((path) => {\r\n        baseUnset(object, path);\r\n    });\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldValue = fields[name];\r\n    if (!type) {\r\n        delete fields[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.filter(Boolean).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, [`[${index}]`]);\r\n                }\r\n            });\r\n            if (options && !options.filter(Boolean).length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === 'select-multiple';\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { name, value } = ref;\r\n    const field = fields[name];\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return getMultipleSelectValue(ref.options);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\r\n    const output = {};\r\n    for (const name in fields) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search)\r\n                    ? search.find((data) => name.startsWith(data))\r\n                    : search && search.nest)) {\r\n            output[name] = getFieldValue(fields, fields[name].ref);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\r\n    const objectAKeys = Object.keys(objectA);\r\n    const objectBKeys = Object.keys(objectB);\r\n    return (objectAKeys.length === objectBKeys.length &&\r\n        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));\r\n};\n\nvar isSameError = (error, { type, types, message, }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isValueMessage = (value) => isObject(value) && !isRegex(value);\r\n    return isValueMessage(validationData)\r\n        ? validationData\r\n        : {\r\n            value: validationData,\r\n            message: '',\r\n        };\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    var _a;\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path\r\n        ? previous[path] && validateAllFieldCriteria\r\n            ? {\r\n                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n            }\r\n            : {\r\n                [path]: previous[path] || Object.assign({ message,\r\n                    type }, (validateAllFieldCriteria\r\n                    ? {\r\n                        types: { [type]: message || true },\r\n                    }\r\n                    : {})),\r\n            }\r\n        : {}))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\r\n    if (validationResolver) {\r\n        return validationResolver(data, context);\r\n    }\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, {\r\n                abortEarly: false,\r\n                context,\r\n            }),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),\r\n        };\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return isArray(values)\r\n        ? values.map((value, key) => getInnerPath(value, key))\r\n        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\r\n};\r\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        value = fieldValues[fieldName];\r\n        watchFields.add(fieldName);\r\n    }\r\n    else {\r\n        value = get(transformToNestObject(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||\r\n    (isOnSubmit && isReValidateOnSubmit) ||\r\n    (isOnSubmit && !isSubmitted) ||\r\n    (isOnBlur && !isBlurEvent && !hasError) ||\r\n    (isReValidateOnBlur && !isBlurEvent && hasError) ||\r\n    (isReValidateOnSubmit && isSubmitted);\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\r\n    const results = transformToNestObject(getFieldsValues(fields));\r\n    return name ? get(results, name, results) : results;\r\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\r\n    let isMatch = false;\r\n    if (!isArray(referenceArray) ||\r\n        !isArray(differenceArray) ||\r\n        referenceArray.length !== differenceArray.length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < referenceArray.length; i++) {\r\n        if (isMatch) {\r\n            break;\r\n        }\r\n        const dataA = referenceArray[i];\r\n        const dataB = differenceArray[i];\r\n        if (isUndefined(dataB) ||\r\n            Object.keys(dataA).length !== Object.keys(dataB).length) {\r\n            isMatch = true;\r\n            break;\r\n        }\r\n        for (const key in dataA) {\r\n            if (dataA[key] !== dataB[key]) {\r\n                isMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isMatch;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const errorsRef = useRef({});\r\n    const touchedFieldsRef = useRef({});\r\n    const fieldArrayDefaultValues = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const isValidRef = useRef(true);\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const validationContextRef = useRef(validationContext);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const [, render] = useState();\r\n    const { isOnBlur, isOnSubmit, isOnChange } = useRef(modeChecker(mode)).current;\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\n    const readFormStateRef = useRef({\r\n        dirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    validationContextRef.current = validationContext;\r\n    const reRender = useCallback(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) ||\r\n                shouldValidateSchemaOrResolver) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || get(errorsRef.current, name);\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, [name]);\r\n        }\r\n        else {\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender = shouldReRender || !get(errorsRef.current, name);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, shouldValidateSchemaOrResolver]);\r\n    const setFieldValue = useCallback((field, rawValue) => {\r\n        const { ref, options } = field;\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref)) {\r\n            if (isString(value)) {\r\n                ref.value = value;\r\n            }\r\n            else {\r\n                ref.files = value;\r\n            }\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, [isWeb]);\r\n    const setDirty = (name) => {\r\n        if (!fieldsRef.current[name] ||\r\n            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {\r\n            return false;\r\n        }\r\n        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\r\n        if (isFieldArray) {\r\n            const fieldArrayName = getFieldArrayParentName(name);\r\n            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\r\n        }\r\n        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==\r\n            isFieldDirty;\r\n        if (isFieldDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = isFieldArray\r\n            ? isFieldDirty\r\n            : !!dirtyFieldsRef.current.size;\r\n        return readFormStateRef.current.dirty\r\n            ? isDirtyChanged\r\n            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\r\n    };\r\n    const setDirtyAndTouchedFields = useCallback((fieldName) => {\r\n        if (setDirty(fieldName) ||\r\n            (!get(touchedFieldsRef.current, fieldName) &&\r\n                readFormStateRef.current.touched)) {\r\n            return !!set(touchedFieldsRef.current, fieldName, true);\r\n        }\r\n    }, []);\r\n    const setInternalValues = useCallback((name, value, parentFieldName) => {\r\n        const isValueArray = isArray(value);\r\n        for (const key in value) {\r\n            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\r\n            const field = fieldsRef.current[fieldName];\r\n            if (isObject(value[key])) {\r\n                setInternalValues(name, value[key], fieldName);\r\n            }\r\n            if (field) {\r\n                setFieldValue(field, value[key]);\r\n                setDirtyAndTouchedFields(fieldName);\r\n            }\r\n        }\r\n    }, [setFieldValue, setDirtyAndTouchedFields]);\r\n    const setInternalValue = useCallback((name, value) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            setFieldValue(field, value);\r\n            const output = setDirtyAndTouchedFields(name);\r\n            if (isBoolean(output)) {\r\n                return output;\r\n            }\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value);\r\n        }\r\n    }, [setDirtyAndTouchedFields, setFieldValue, setInternalValues]);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (payload) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            payload.forEach((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, [name]);\r\n                }\r\n            });\r\n            reRender();\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [\r\n        reRender,\r\n        shouldRenderBaseOnError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const triggerValidation = useCallback(async (payload) => {\r\n        const fields = payload || Object.keys(fieldsRef.current);\r\n        if (shouldValidateSchemaOrResolver) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [\r\n        executeSchemaOrResolverValidation,\r\n        executeValidation,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n    ]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    function setValue(names, valueOrShouldValidate, shouldValidate) {\r\n        let shouldRender = false;\r\n        const isArrayValue = isArray(names);\r\n        (isArrayValue\r\n            ? names\r\n            : [names]).forEach((name) => {\r\n            const isStringFieldName = isString(name);\r\n            shouldRender =\r\n                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName\r\n                    ? valueOrShouldValidate\r\n                    : Object.values(name)[0]) || isArrayValue\r\n                    ? true\r\n                    : isFieldWatched(name);\r\n        });\r\n        if (shouldRender || isArrayValue) {\r\n            reRender();\r\n        }\r\n        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {\r\n            triggerValidation(isArrayValue ? undefined : names);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = get(errors, name);\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = skipValidation({\r\n                hasError: !!currentError,\r\n                isOnChange,\r\n                isBlurEvent,\r\n                isOnSubmit,\r\n                isReValidateOnSubmit,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n                isSubmitted: isSubmittedRef.current,\r\n            });\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !get(touchedFieldsRef.current, name) &&\r\n                readFormStateRef.current.touched) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                shouldRender = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldRender && reRender();\r\n            }\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\r\n                const previousFormIsValid = isValidRef.current;\r\n                isValidRef.current = isEmptyObject(errors);\r\n                error = (get(errors, name)\r\n                    ? { [name]: get(errors, name) }\r\n                    : {});\r\n                if (previousFormIsValid !== isValidRef.current) {\r\n                    shouldRender = true;\r\n                }\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            }\r\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaOrResolver = useCallback((values = {}) => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, \r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [reRender, validateAllFieldCriteria, validationResolver]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => {\r\n        if (handleChangeRef.current && field) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field ||\r\n            (field &&\r\n                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&\r\n                !forceDelete)) {\r\n            return;\r\n        }\r\n        removeFieldEventListener(field, forceDelete);\r\n        const { name } = field.ref;\r\n        errorsRef.current = unset(errorsRef.current, [name]);\r\n        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\r\n        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\r\n        [\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach((data) => data.current.delete(name));\r\n        if (readFormStateRef.current.isValid ||\r\n            readFormStateRef.current.touched) {\r\n            reRender();\r\n            if (shouldValidateSchemaOrResolver) {\r\n                validateSchemaOrResolver();\r\n            }\r\n        }\r\n    }, [\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        validateSchemaOrResolver,\r\n        removeFieldEventListener,\r\n    ]);\r\n    function clearError(name) {\r\n        if (name) {\r\n            unset(errorsRef.current, isArray(name) ? name : [name]);\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, shouldRender, }) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(errorsRef.current[name], {\r\n            type,\r\n            message,\r\n            types,\r\n        })) {\r\n            set(errorsRef.current, name, {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            });\r\n            if (shouldRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })), { shouldRender: true }));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach((error) => setInternalError(Object.assign({}, error)));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const watchFields = watchFieldsRef.current;\r\n        const isDefaultValueUndefined = isUndefined(defaultValue);\r\n        const combinedDefaultValues = isDefaultValueUndefined\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;\r\n        return fieldNames && fieldNames.nest\r\n            ? transformToNestObject(result)\r\n            : result;\r\n    }\r\n    function unregister(name) {\r\n        if (fieldsRef.current) {\r\n            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            // eslint-disable-next-line no-console\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (isRadioOrCheckbox\r\n            ? field &&\r\n                isArray(field.options) &&\r\n                field.options.filter(Boolean).find((option) => {\r\n                    return value === option.ref.value && option.ref === ref;\r\n                })\r\n            : field && ref === field.ref) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            defaultValue = get(defaultValuesRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (shouldValidateSchemaOrResolver &&\r\n            !isFieldArray &&\r\n            readFormStateRef.current.isValid) {\r\n            validateSchemaOrResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners({\r\n                field: isRadioOrCheckbox && field.options\r\n                    ? field.options[field.options.length - 1]\r\n                    : field,\r\n                isRadioOrCheckbox,\r\n                handleChange: handleChangeRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, validationOptions) {\r\n        if (isWindowUndefined) {\r\n            return;\r\n        }\r\n        if (isString(refOrValidationOptions)) {\r\n            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\r\n            registerFieldsRef(refOrValidationOptions, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);\r\n    }\r\n    const handleSubmit = useCallback((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        const fields = fieldsRef.current;\r\n        let fieldValues = getFieldsValues(fields);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fields)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else {\r\n                            if (fieldsWithValidationRef.current.has(name)) {\r\n                                validFieldsRef.current.add(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(transformToNestObject(fieldValues), e);\r\n            }\r\n            else {\r\n                errorsRef.current = fieldErrors;\r\n                if (submitFocusError && isWeb) {\r\n                    focusOnErrorField(fields, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        isWeb,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        submitFocusError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        fieldsRef.current = {};\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!dirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = new Set();\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return fieldsRef.current[payload]\r\n                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)\r\n                : get(defaultValuesRef.current, payload);\r\n        }\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValuesRef.current\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? transformToNestObject(outputValues)\r\n            : outputValues;\r\n    }\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            process.env.NODE_ENV === 'production' &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!shouldValidateSchemaOrResolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        triggerValidation,\r\n        setValue: useCallback(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            triggerValidation,\r\n        ]),\r\n        register: useCallback(register, [\r\n            defaultValuesRef.current,\r\n            defaultValuesAtRenderRef.current,\r\n        ]),\r\n        unregister: useCallback(unregister, []),\r\n        getValues: useCallback(getValues, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,\r\n        reRender }, (shouldValidateSchemaOrResolver\r\n        ? { validateSchemaIsValid: validateSchemaOrResolver }\r\n        : {})), { mode: {\r\n            isOnBlur,\r\n            isOnSubmit,\r\n            isOnChange,\r\n        }, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnSubmit,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        readFormStateRef,\r\n        defaultValuesRef }), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: useCallback(reset, []), clearError: useCallback(clearError, []), setError: useCallback(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(_a) {\r\n    var { children, formState, errors } = _a, restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nvar getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {\r\n    for (const removeIndex of removeIndexes) {\r\n        if (indexes.indexOf(removeIndex) < 0) {\r\n            notFoundIndexes.push(removeIndex);\r\n        }\r\n    }\r\n    for (const index of indexes.sort()) {\r\n        if (removeIndexes.indexOf(index) > -1) {\r\n            updatedIndexes.push(-1);\r\n            count++;\r\n        }\r\n        else {\r\n            updatedIndexes.push(index -\r\n                count -\r\n                (notFoundIndexes.length\r\n                    ? notFoundIndexes\r\n                        .map((notFoundIndex) => notFoundIndex < index)\r\n                        .filter(Boolean).length\r\n                    : 0));\r\n        }\r\n    }\r\n    return updatedIndexes;\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return data.filter(Boolean);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || null]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || null]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;\r\n    const getDefaultValues = () => [\r\n        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\r\n            ? fieldArrayDefaultValues.current\r\n            : defaultValuesRef.current, name, []),\r\n    ];\r\n    const memoizedDefaultValues = useRef(getDefaultValues());\r\n    const [fields, setField] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    const [isDeleted, setIsDeleted] = useState(false);\r\n    const allFields = useRef(fields);\r\n    const isNameKey = isKey(name);\r\n    allFields.current = fields;\r\n    if (isNameKey) {\r\n        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {\r\n        let render = shouldRender;\r\n        const values = isArray(value) ? value : [value];\r\n        if (readFormStateRef.current.dirty) {\r\n            const dirtyFieldIndexesAndValues = {};\r\n            if (isPrePend || isRemove) {\r\n                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\r\n                    if (isMatchFieldArrayName(dirtyField, name)) {\r\n                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\r\n                        if (matchedIndexes) {\r\n                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\r\n                            if (dirtyFieldIndexesAndValues[matchIndex]) {\r\n                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\r\n                            }\r\n                            else {\r\n                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\r\n                            }\r\n                        }\r\n                        dirtyFieldsRef.current.delete(dirtyField);\r\n                    }\r\n                }\r\n            }\r\n            if (!isUndefined(index) || isPrePend) {\r\n                const updatedDirtyFieldIndexes = isUndefined(index)\r\n                    ? []\r\n                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);\r\n                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\r\n                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\r\n                    if (updateIndex > -1) {\r\n                        for (const value of values) {\r\n                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\r\n                            if (matchedIndexes) {\r\n                                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend\r\n                                    ? +matchedIndexes[matchedIndexes.length - 1] +\r\n                                        values.length\r\n                                    : updateIndex}$1`));\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (!isRemove) {\r\n                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\r\n                isDirtyRef.current = true;\r\n            }\r\n            render = true;\r\n        }\r\n        if (render && !isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.dirty) {\r\n            isDirtyRef.current = isUndefined(flagOrFields)\r\n                ? true\r\n                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const mapCurrentFieldsValueWithState = () => {\r\n        const currentFieldsValue = get(getValues({ nest: true }), name);\r\n        if (isArray(currentFieldsValue)) {\r\n            for (let i = 0; i < currentFieldsValue.length; i++) {\r\n                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\r\n            }\r\n        }\r\n    };\r\n    const append = (value) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        modifyDirtyFields({ value });\r\n    };\r\n    const prepend$1 = (value) => {\r\n        let shouldRender = false;\r\n        resetFields();\r\n        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\r\n            shouldRender = true;\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isPrePend: true,\r\n            value,\r\n        });\r\n    };\r\n    const remove = (index) => {\r\n        let shouldRender = false;\r\n        const isIndexUndefined = isUndefined(index);\r\n        if (!isIndexUndefined) {\r\n            mapCurrentFieldsValueWithState();\r\n        }\r\n        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(removeArrayAt(allFields.current, index));\r\n        setIsDeleted(true);\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\r\n            if (!errorsRef.current[name].filter(Boolean).length) {\r\n                delete errorsRef.current[name];\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isRemove: true,\r\n            index,\r\n        });\r\n    };\r\n    const insert$1 = (index, value) => {\r\n        mapCurrentFieldsValueWithState();\r\n        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\r\n            reRender();\r\n        }\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        swapArrayAt(allFields.current, indexA, indexB);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            swapArrayAt(errorsRef.current[name], indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\r\n            reRender();\r\n        }\r\n    };\r\n    const move = (from, to) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        moveArrayAt(allFields.current, from, to);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            moveArrayAt(errorsRef.current[name], from, to);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            moveArrayAt(touchedFieldsRef.current[name], from, to);\r\n            reRender();\r\n        }\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    useEffect(() => {\r\n        if (isNameKey &&\r\n            isDeleted &&\r\n            fieldArrayDefaultValues.current[name] &&\r\n            fields.length < fieldArrayDefaultValues.current[name].length) {\r\n            fieldArrayDefaultValues.current[name].pop();\r\n        }\r\n    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\r\n    useEffect(() => {\r\n        if (isWatchAllRef && isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        fieldArrayNames.add(name);\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [fields, name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isCheckboxInput || isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, fieldsRef, fieldArrayNamesRef, } = control || methods.control;\r\n    const [value, setInputStateValue] = useState(isUndefined(defaultValue)\r\n        ? get(defaultValuesRef.current, name)\r\n        : defaultValue);\r\n    const valueRef = useRef(value);\r\n    const isCheckboxInput = isBoolean(value);\r\n    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\r\n    const rulesRef = useRef(rules);\r\n    const onFocusRef = useRef(onFocus);\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    rulesRef.current = rules;\r\n    const shouldValidate = () => !skipValidation({\r\n        hasError: !!get(errorsRef.current, name),\r\n        isOnBlur,\r\n        isOnSubmit,\r\n        isOnChange,\r\n        isReValidateOnBlur,\r\n        isReValidateOnSubmit,\r\n        isSubmitted,\r\n    });\r\n    const commonTask = (event) => {\r\n        const data = getInputValue(event, isCheckboxInput);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());\r\n    const handleChange = (event) => {\r\n        const data = commonTask(event);\r\n        setValue(name, data, shouldValidate());\r\n    };\r\n    const registerField = useCallback(() => {\r\n        if (!isNotFieldArray) {\r\n            removeFieldEventListener(fieldsRef.current[name], true);\r\n        }\r\n        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n            set(data) {\r\n                setInputStateValue(data);\r\n                valueRef.current = data;\r\n            },\r\n            get() {\r\n                return valueRef.current;\r\n            },\r\n        }), rulesRef.current);\r\n    }, [\r\n        isNotFieldArray,\r\n        fieldsRef,\r\n        rulesRef,\r\n        name,\r\n        onFocusRef,\r\n        register,\r\n        removeFieldEventListener,\r\n    ]);\r\n    useEffect(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    useEffect(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(isUndefined(defaultValue)\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : defaultValue);\r\n            }\r\n        }\r\n    });\r\n    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange\r\n        ? { [onChangeName]: eventWrapper(onChange) }\r\n        : { [onChangeName]: handleChange })), (onBlur || shouldReValidateOnBlur\r\n        ? {\r\n            [onBlurName]: (...args) => {\r\n                if (onBlur) {\r\n                    onBlur(args);\r\n                }\r\n                if (shouldReValidateOnBlur) {\r\n                    triggerValidation(name);\r\n                }\r\n            },\r\n        }\r\n        : {})), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });\r\n    return isValidElement(InnerComponent)\r\n        ? cloneElement(InnerComponent, props)\r\n        : createElement(InnerComponent, props);\r\n};\n\nconst ErrorMessage = (_a) => {\r\n    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\r\n    const methods = useFormContext();\r\n    const error = get(errors || methods.errors, name);\r\n    if (!error) {\r\n        return null;\r\n    }\r\n    const { message: messageFromRegister, types } = error;\r\n    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children\r\n            ? children({ message: messageFromRegister || message, messages: types })\r\n            : messageFromRegister || message });\r\n    return InnerComponent ? (isValidElement(InnerComponent) ? (cloneElement(InnerComponent, props)) : (createElement(InnerComponent, props))) : (createElement(Fragment, Object.assign({}, props)));\r\n};\n\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };\n","import _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\n\nvar _leaveRenders, _enterRenders;\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { ENTERED, ENTERING, EXITING } from './Transition';\nimport TransitionGroupContext from './TransitionGroupContext';\n\nfunction areChildrenDifferent(oldChildren, newChildren) {\n  if (oldChildren === newChildren) return false;\n\n  if (React.isValidElement(oldChildren) && React.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Enum of modes for SwitchTransition component\n * @enum { string }\n */\n\n\nexport var modes = {\n  out: 'out-in',\n  in: 'in-out'\n};\n\nvar callHook = function callHook(element, name, cb) {\n  return function () {\n    var _element$props;\n\n    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);\n    cb();\n  };\n};\n\nvar leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function (_ref) {\n  var current = _ref.current,\n      changeState = _ref.changeState;\n  return React.cloneElement(current, {\n    in: false,\n    onExited: callHook(current, 'onExited', function () {\n      changeState(ENTERING, null);\n    })\n  });\n}, _leaveRenders[modes.in] = function (_ref2) {\n  var current = _ref2.current,\n      changeState = _ref2.changeState,\n      children = _ref2.children;\n  return [current, React.cloneElement(children, {\n    in: true,\n    onEntered: callHook(children, 'onEntered', function () {\n      changeState(ENTERING);\n    })\n  })];\n}, _leaveRenders);\nvar enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function (_ref3) {\n  var children = _ref3.children,\n      changeState = _ref3.changeState;\n  return React.cloneElement(children, {\n    in: true,\n    onEntered: callHook(children, 'onEntered', function () {\n      changeState(ENTERED, React.cloneElement(children, {\n        in: true\n      }));\n    })\n  });\n}, _enterRenders[modes.in] = function (_ref4) {\n  var current = _ref4.current,\n      children = _ref4.children,\n      changeState = _ref4.changeState;\n  return [React.cloneElement(current, {\n    in: false,\n    onExited: callHook(current, 'onExited', function () {\n      changeState(ENTERED, React.cloneElement(children, {\n        in: true\n      }));\n    })\n  }), React.cloneElement(children, {\n    in: true\n  })];\n}, _enterRenders);\n/**\n * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).\n * You can use it when you want to control the render between state transitions.\n * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.\n *\n * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.\n * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child\n *\n * ```jsx\n *\n * function App() {\n *  const [state, setState] = useState(false);\n *  return (\n *    <SwitchTransition>\n *      <FadeTransition key={state ? \"Goodbye, world!\" : \"Hello, world!\"}\n *        addEndListener={(node, done) => node.addEventListener(\"transitionend\", done, false)}\n *        classNames='fade' >\n *        <button onClick={() => setState(state => !state)}>\n *          {state ? \"Goodbye, world!\" : \"Hello, world!\"}\n *        </button>\n *      </FadeTransition>\n *    </SwitchTransition>\n *  )\n * }\n * ```\n */\n\nvar SwitchTransition =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(SwitchTransition, _React$Component);\n\n  function SwitchTransition() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      status: ENTERED,\n      current: null\n    };\n    _this.appeared = false;\n\n    _this.changeState = function (status, current) {\n      if (current === void 0) {\n        current = _this.state.current;\n      }\n\n      _this.setState({\n        status: status,\n        current: current\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = SwitchTransition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.appeared = true;\n  };\n\n  SwitchTransition.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (props.children == null) {\n      return {\n        current: null\n      };\n    }\n\n    if (state.status === ENTERING && props.mode === modes.in) {\n      return {\n        status: ENTERING\n      };\n    }\n\n    if (state.current && areChildrenDifferent(state.current, props.children)) {\n      return {\n        status: EXITING\n      };\n    }\n\n    return {\n      current: React.cloneElement(props.children, {\n        in: true\n      })\n    };\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        mode = _this$props.mode,\n        _this$state = this.state,\n        status = _this$state.status,\n        current = _this$state.current;\n    var data = {\n      children: children,\n      current: current,\n      changeState: this.changeState,\n      status: status\n    };\n    var component;\n\n    switch (status) {\n      case ENTERING:\n        component = enterRenders[mode](data);\n        break;\n\n      case EXITING:\n        component = leaveRenders[mode](data);\n        break;\n\n      case ENTERED:\n        component = current;\n    }\n\n    return React.createElement(TransitionGroupContext.Provider, {\n      value: {\n        isMounting: !this.appeared\n      }\n    }, component);\n  };\n\n  return SwitchTransition;\n}(React.Component);\n\nSwitchTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Transition modes.\n   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.\n   * `in-out: New element transitions in first, then when complete, the current element transitions out.`\n   *\n   * @type {'out-in'|'in-out'}\n   */\n  mode: PropTypes.oneOf([modes.in, modes.out]),\n\n  /**\n   * Any `Transition` or `CSSTransition` component\n   */\n  children: PropTypes.oneOfType([PropTypes.element.isRequired])\n} : {};\nSwitchTransition.defaultProps = {\n  mode: modes.out\n};\nexport default SwitchTransition;","function replaceClassName(origClass, classToRemove) {\n  return origClass.replace(new RegExp(\"(^|\\\\s)\" + classToRemove + \"(?:\\\\s|$)\", 'g'), '$1').replace(/\\s+/g, ' ').replace(/^\\s*|\\s*$/g, '');\n}\n\nexport default function removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else if (typeof element.className === 'string') {\n    ;\n    element.className = replaceClassName(element.className, className);\n  } else {\n    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));\n  }\n}","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport PropTypes from 'prop-types';\nimport addOneClass from 'dom-helpers/addClass';\nimport removeOneClass from 'dom-helpers/removeClass';\nimport React from 'react';\nimport Transition from './Transition';\nimport { classNamesShape } from './utils/PropTypes';\n\nvar _addClass = function addClass(node, classes) {\n  return node && classes && classes.split(' ').forEach(function (c) {\n    return addOneClass(node, c);\n  });\n};\n\nvar removeClass = function removeClass(node, classes) {\n  return node && classes && classes.split(' ').forEach(function (c) {\n    return removeOneClass(node, c);\n  });\n};\n/**\n * A transition component inspired by the excellent\n * [ng-animate](http://www.nganimate.org/) library, you should use it if you're\n * using CSS transitions or animations. It's built upon the\n * [`Transition`](https://reactcommunity.org/react-transition-group/transition)\n * component, so it inherits all of its props.\n *\n * `CSSTransition` applies a pair of class names during the `appear`, `enter`,\n * and `exit` states of the transition. The first class is applied and then a\n * second `*-active` class in order to activate the CSS transition. After the\n * transition, matching `*-done` class names are applied to persist the\n * transition state.\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <CSSTransition in={inProp} timeout={200} classNames=\"my-node\">\n *         <div>\n *           {\"I'll receive my-node-* classes\"}\n *         </div>\n *       </CSSTransition>\n *       <button type=\"button\" onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the `in` prop is set to `true`, the child component will first receive\n * the class `example-enter`, then the `example-enter-active` will be added in\n * the next tick. `CSSTransition` [forces a\n * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * between before adding the `example-enter-active`. This is an important trick\n * because it allows us to transition between `example-enter` and\n * `example-enter-active` even though they were added immediately one after\n * another. Most notably, this is what makes it possible for us to animate\n * _appearance_.\n *\n * ```css\n * .my-node-enter {\n *   opacity: 0;\n * }\n * .my-node-enter-active {\n *   opacity: 1;\n *   transition: opacity 200ms;\n * }\n * .my-node-exit {\n *   opacity: 1;\n * }\n * .my-node-exit-active {\n *   opacity: 0;\n *   transition: opacity 200ms;\n * }\n * ```\n *\n * `*-active` classes represent which styles you want to animate **to**.\n *\n * **Note**: If you're using the\n * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)\n * prop, make sure to define styles for `.appear-*` classes as well.\n */\n\n\nvar CSSTransition =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(CSSTransition, _React$Component);\n\n  function CSSTransition() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.appliedClasses = {\n      appear: {},\n      enter: {},\n      exit: {}\n    };\n\n    _this.onEnter = function (node, appearing) {\n      _this.removeClasses(node, 'exit');\n\n      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');\n\n      if (_this.props.onEnter) {\n        _this.props.onEnter(node, appearing);\n      }\n    };\n\n    _this.onEntering = function (node, appearing) {\n      var type = appearing ? 'appear' : 'enter';\n\n      _this.addClass(node, type, 'active');\n\n      if (_this.props.onEntering) {\n        _this.props.onEntering(node, appearing);\n      }\n    };\n\n    _this.onEntered = function (node, appearing) {\n      var type = appearing ? 'appear' : 'enter';\n\n      _this.removeClasses(node, type);\n\n      _this.addClass(node, type, 'done');\n\n      if (_this.props.onEntered) {\n        _this.props.onEntered(node, appearing);\n      }\n    };\n\n    _this.onExit = function (node) {\n      _this.removeClasses(node, 'appear');\n\n      _this.removeClasses(node, 'enter');\n\n      _this.addClass(node, 'exit', 'base');\n\n      if (_this.props.onExit) {\n        _this.props.onExit(node);\n      }\n    };\n\n    _this.onExiting = function (node) {\n      _this.addClass(node, 'exit', 'active');\n\n      if (_this.props.onExiting) {\n        _this.props.onExiting(node);\n      }\n    };\n\n    _this.onExited = function (node) {\n      _this.removeClasses(node, 'exit');\n\n      _this.addClass(node, 'exit', 'done');\n\n      if (_this.props.onExited) {\n        _this.props.onExited(node);\n      }\n    };\n\n    _this.getClassNames = function (type) {\n      var classNames = _this.props.classNames;\n      var isStringClassNames = typeof classNames === 'string';\n      var prefix = isStringClassNames && classNames ? classNames + \"-\" : '';\n      var baseClassName = isStringClassNames ? \"\" + prefix + type : classNames[type];\n      var activeClassName = isStringClassNames ? baseClassName + \"-active\" : classNames[type + \"Active\"];\n      var doneClassName = isStringClassNames ? baseClassName + \"-done\" : classNames[type + \"Done\"];\n      return {\n        baseClassName: baseClassName,\n        activeClassName: activeClassName,\n        doneClassName: doneClassName\n      };\n    };\n\n    return _this;\n  }\n\n  var _proto = CSSTransition.prototype;\n\n  _proto.addClass = function addClass(node, type, phase) {\n    var className = this.getClassNames(type)[phase + \"ClassName\"];\n\n    if (type === 'appear' && phase === 'done') {\n      className += \" \" + this.getClassNames('enter').doneClassName;\n    } // This is for to force a repaint,\n    // which is necessary in order to transition styles when adding a class name.\n\n\n    if (phase === 'active') {\n      /* eslint-disable no-unused-expressions */\n      node && node.scrollTop;\n    }\n\n    this.appliedClasses[type][phase] = className;\n\n    _addClass(node, className);\n  };\n\n  _proto.removeClasses = function removeClasses(node, type) {\n    var _this$appliedClasses$ = this.appliedClasses[type],\n        baseClassName = _this$appliedClasses$.base,\n        activeClassName = _this$appliedClasses$.active,\n        doneClassName = _this$appliedClasses$.done;\n    this.appliedClasses[type] = {};\n\n    if (baseClassName) {\n      removeClass(node, baseClassName);\n    }\n\n    if (activeClassName) {\n      removeClass(node, activeClassName);\n    }\n\n    if (doneClassName) {\n      removeClass(node, doneClassName);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        _ = _this$props.classNames,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"classNames\"]);\n\n    return React.createElement(Transition, _extends({}, props, {\n      onEnter: this.onEnter,\n      onEntered: this.onEntered,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }));\n  };\n\n  return CSSTransition;\n}(React.Component);\n\nCSSTransition.defaultProps = {\n  classNames: ''\n};\nCSSTransition.propTypes = process.env.NODE_ENV !== \"production\" ? _extends({}, Transition.propTypes, {\n  /**\n   * The animation classNames applied to the component as it appears, enters,\n   * exits or has finished the transition. A single name can be provided and it\n   * will be suffixed for each stage: e.g.\n   *\n   * `classNames=\"fade\"` applies `fade-appear`, `fade-appear-active`,\n   * `fade-appear-done`, `fade-enter`, `fade-enter-active`, `fade-enter-done`,\n   * `fade-exit`, `fade-exit-active`, and `fade-exit-done`.\n   *\n   * **Note**: `fade-appear-done` and `fade-enter-done` will _both_ be applied.\n   * This allows you to define different behavior for when appearing is done and\n   * when regular entering is done, using selectors like\n   * `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply an\n   * epic entrance animation when element first appears in the DOM using\n   * [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can\n   * simply use `fade-enter-done` for defining both cases.\n   *\n   * Each individual classNames can also be specified independently like:\n   *\n   * ```js\n   * classNames={{\n   *  appear: 'my-appear',\n   *  appearActive: 'my-active-appear',\n   *  appearDone: 'my-done-appear',\n   *  enter: 'my-enter',\n   *  enterActive: 'my-active-enter',\n   *  enterDone: 'my-done-enter',\n   *  exit: 'my-exit',\n   *  exitActive: 'my-active-exit',\n   *  exitDone: 'my-done-exit',\n   * }}\n   * ```\n   *\n   * If you want to set these classes using CSS Modules:\n   *\n   * ```js\n   * import styles from './styles.css';\n   * ```\n   *\n   * you might want to use camelCase in your CSS file, that way could simply\n   * spread them instead of listing them one by one:\n   *\n   * ```js\n   * classNames={{ ...styles }}\n   * ```\n   *\n   * @type {string | {\n   *  appear?: string,\n   *  appearActive?: string,\n   *  appearDone?: string,\n   *  enter?: string,\n   *  enterActive?: string,\n   *  enterDone?: string,\n   *  exit?: string,\n   *  exitActive?: string,\n   *  exitDone?: string,\n   * }}\n   */\n  classNames: classNamesShape,\n\n  /**\n   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is\n   * applied.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * A `<Transition>` callback fired immediately after the 'enter-active' or\n   * 'appear-active' class is applied.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * A `<Transition>` callback fired immediately after the 'enter' or\n   * 'appear' classes are **removed** and the `done` class is added to the DOM node.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * A `<Transition>` callback fired immediately after the 'exit' class is\n   * applied.\n   *\n   * @type Function(node: HtmlElement)\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.\n   *\n   * @type Function(node: HtmlElement)\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * A `<Transition>` callback fired immediately after the 'exit' classes\n   * are **removed** and the `exit-done` class is added to the DOM node.\n   *\n   * @type Function(node: HtmlElement)\n   */\n  onExited: PropTypes.func\n}) : {};\nexport default CSSTransition;","import hasClass from './hasClass';\nexport default function addClass(element, className) {\n  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + \" \" + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + \" \" + className);\n}","export default function hasClass(element, className) {\n  if (element.classList) return !!className && element.classList.contains(className);\n  return (\" \" + (element.className.baseVal || element.className) + \" \").indexOf(\" \" + className + \" \") !== -1;\n}"],"sourceRoot":""}